#pragma config(Motor,  port2,           armTendon,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           drive,         tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           armPitch,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port7,           armPivot,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           reefClaws,     tmotorVex269_MC29, openLoop)
#pragma config(Sensor, in1,    potent,         sensorPotentiometer)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////
//           {Cord to Port List}            //
//////////////////////////////////////////////
//              (Motor Ports)               //
//////////////////////////////////////////////
//[2]>     Tendon cord goes in port 2 .     //
//---|--------------------------------------//
// 3 |           Port 3 is empty.           //
//---|--------------------------------------//
//[4]>      Drive cord goes in port 4 .     //
//---|--------------------------------------//
// 5 |           Port 5 is empty.           //
//---|--------------------------------------//
//[6]>  Arm vertical motor goes to port 6.  //
//---|--------------------------------------//
//[7]> Arm horizontal motor goes to port 7. //
//---|--------------------------------------//
// 8 |           Port 8 is empty.           //
//---|--------------------------------------//
//[9]>      Claw cord goes in port 9 .      //
//////////////////////////////////////////////
//          (Sensor Ports "in")             //
//////////////////////////////////////////////
//[1]>   Potentiometer goes in port in1.    //
//////////////////////////////////////////////
//Aesthetic design courtesy of Grant Loving //
//////////////////////////////////////////////

//Controls//

//6U opens the claw//
//6D closes the claw//
//Channel 4 controls the arm's "tendon"//
//Channel 1 controls the speed of armPivot//
//Channel 3 drives the robot//
//Channel 2 controls the position of the arm//

bool safetyLock = false;

int TARGET = 4000;
// Desired arm position //

int MAX_OUT = 90;
// Maximum motor value //

int MAXPOT = 4095;
int MINPOT = 500;

int potVal = 0;

int difErr = 0;

int curErr = 0;

int curSpeed = 0;

float joyCal = 0.035;

// Joystick value multiplied by this //

float Kp = 0.05;
// Proportional. Difference from current to target //

float Ki = 0.001;
// Integral. Accelerates if it takes longer //

float Kd = 0.05;
// Differential. Increases and decreases speed according to difference from current to target //

int totErr = 0;
// Total difference from current to target //

int preErr = 0;
// Previous difference from current to target //

//int jointSpeed = 0;
/*
integer variable "jointSpeed":
This variable is used to store and recall the desired speed of the arm's vertical movement
through use of the task "speedWeightCompensate". This task is designed so the speed is
incremented slowly, creating smoother movements, as opposed to abruptly starting and
stopping the motor.
*/

int tendonSpeed = 0;
/*
integer variable "tendonSpeed":
This variable is used to change the speed of the motor that pulls on and releases the
arm's "tendon".
*/

task toggleLock()
{
	if(vexRT[Btn7U])
	{
		safetyLock = true;
	}
	if(vexRT[Btn8U])
	{
		TARGET = 4000;
		wait1Msec(1000);
		motor[armPitch] = 0;
		safetyLock = false;
	}
}

task manualControl()
{
	while(vexRT[Btn5U])
	{
		if(abs(vexRT[Ch2]) > 20)
		{
			curSpeed += vexRT[Ch2] * 0.1;
			motor[armPitch] = curSpeed;
			wait1Msec(250);
		}
	}
	while(vexRT[Btn5D])
	{
		if(vexRT[Btn8R])
		{
			motor[armPitch] = 127;
		}
		if(vexRT[Btn8L])
		{
			motor[armPitch] = -127;
		}
		if((vexRT[Btn8R] == false) && (vexRT[Btn8L] == false))
		{
			motor[armPitch] = 0;
		}
	}
}

task PID()// Changes motor speed based on target //
{
	while(safetyLock && (vexRT[Btn5U] == false))
	{
		if(potVal < MINPOT)
		{
			potVal = 1750;
		}
		else
		{
			potVal = SensorValue[potent];
		}

		curErr = potVal - TARGET;
		// Assigns the value of TARGET minus the value of "potent" to curErr //

		if(abs(totErr) < MAXPOT)
		{
			totErr += curErr;
		}
		// Adds the current error to the total error //

		difErr = curErr - preErr;
		// Assigns the value of the current error minus the previous error to difErr //

		curSpeed = curErr * Kp + totErr * Ki + difErr * Kd ;
		// Assigns curErr * Kp + totErr * Ki + difErr * Kd to curSpeed //

		if(abs(curSpeed) > MAX_OUT)// Prevents curSpeed from going past the maximum //
		{
			curSpeed = (curSpeed / abs(curSpeed))* MAX_OUT;
		}
		motor[armPitch] = curSpeed;
		preErr = curErr;
		wait1Msec(40);
	}
}

task controlTarget()// Controls the value of TARGET //
{
	while(safetyLock && (vexRT[Btn5U] == false))
	{
		while(abs(vexRT[Ch2]) > 20)// Threshold //
		{
			if(TARGET < MINPOT)// Minimum value of TARGET //
			{
				TARGET = MINPOT;
			}
			else if(TARGET > MAXPOT)// Maximum value of TARGET //
			{
				TARGET = MAXPOT;
			}
			else// Adds and subtracts the value of the joystick to TARGET 4 times every second //
			{
				TARGET += vexRT[Ch2] * joyCal;
				wait1Msec(25);
			}
		}
	}
}

task driveRobot()// task to move the robot along current //
{
	while(true)
	{
		if(abs(vexRT[Ch3]) > 20)
		{
			motor[drive] = vexRT[Ch3];
		}
		else
		{
			motor[drive] = 0;
		}
	}
}

task armRotation()// task to control the horizontal rotation of the arm //
{
	if((vexRT[Ch1] > 42) || (vexRT[Ch1] < -42))
	{
		motor[armPivot] = vexRT[Ch1];
	}
	else
	{

		motor[armPivot] = 0;
	}
}

task tendonFlux()// task to control the extention and contraction of the arm //
{
	while(true)
	{
		tendonSpeed = vexRT[Ch4];
		motor[armTendon] = tendonSpeed;
	}
}

task clawControl()// task to control the claws //
{

	if(vexRT[Btn6D])
	{
		motor[reefClaws] = 127;
	}

	if(vexRT[Btn6U])
	{
		motor[reefClaws] = -127;
	}
}
/*task speedWeightCompensate()// task to control the arm's vertical movement //
{
while(vexRT[Btn6U] == false)
{
repeatUntil(vexRT[Btn6U])
{
wait1Msec(500);
while(vexRT[Ch4] > 115)
{
armSpeed += 5;
motor[armPitch] = armSpeed;
}

while((vexRT[Ch4] >= -115) && (vexRT[Ch4] <= 115))
{
armSpeed *= 0.9;
motor[armPitch] = armSpeed;
}

while(vexRT[Ch4] < -115)
{
armSpeed -= 5;
motor[armPitch] = armSpeed;
}

while(true)
{
motor[armPitch] = armSpeed;
}
}
}

while(true)
{
if(vexRT[Btn7R])
{
if(jointSpeed<=127)
{
jointSpeed += 1;
motor[armPitch] = jointSpeed;
wait1Msec(10);
}
else
{
jointSpeed = 127;
motor[armPitch] = jointSpeed;
}
}
if(vexRT[Btn7D])
{
if(jointSpeed>=-127)
{
jointSpeed -= 1;
motor[armPitch] = jointSpeed;
wait1Msec(10);
}
else
{
jointSpeed = -127;
motor[armPitch] = jointSpeed;
}
}
if(vexRT[Btn7L] && (jointSpeed > 7))
{
jointSpeed -= 7;
motor[armPitch] = jointSpeed;
}
if(vexRT[Btn7L] && (jointSpeed < -7))
{
jointSpeed += 7;
motor[armPitch] = jointSpeed;
}
if(vexRT[Btn7L] && (jointSpeed > -7) && (jointSpeed < 7))
{
jointSpeed = 0;
motor[armPitch] = jointSpeed;
}

if(abs(vexRT[Ch4]) > 15)
{
motor[armPitch] = vexRT[Ch2];
}
else
{
motor[armPitch] = 0;
}
}
}*/

task main()
{
	while(true)
	{
		//startTask(speedWeightCompensate);
		startTask(clawControl);
		startTask(driveRobot);
		startTask(armRotation);
		startTask(tendonFlux);
		startTask(toggleLock);
		startTask(PID);
		startTask(controlTarget);
		startTask(manualControl);
	}
}
